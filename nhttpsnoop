#!/bin/bash

#
# nhttpsnoop: snoop Node HTTP requests
#

function usage
{
        cat >&2 << USAGE
usage: $nhs_arg0 [-lnt] [-o col,...] [-p pid,...]

Trace Node.js HTTP server activity.  By default, all requests from all Node.js
servers on the system are traced, and each one is displayed as it completes.

Options:

    -l            Display two lines for each request: one when the request is
                  received, and one when the response is sent (instead of just
                  one line when the response is sent).  Note that these lines
                  may not be adjacent, since multiple requests may be received
                  before any responses are sent if the request handling is
                  asynchronous.

    -n            Don't actually run DTrace, but instead just print out the D
                  script that would be used.

    -o col,...    Display the specified columns instead of the default output.
                  Available columns include:

                latency time in microseconds between the request being received
                        and the response being sent.  With -l, this field is
                        blank for the line denoting the start of the request.
        
                method  Request's HTTP method
        
                path    Request's HTTP URL path (excludes query parameters)
        
                pid     process identifier
        
                raddr   Client's IPv4 address
        
                rport   Client's TCP port
        
                time    relative time of the event from when $nhs_arg0 started
        
                url     Request's full HTTP URL, including query parameters
        
    -p pid,...    Only trace the specified processes.

    -t ARGTYPE    Specify which probe arguments to use, which must be one of
                  "translated" or "simple".  Translated arguments are more
                  extensible, more efficient, and the only reliable approach on
                  systems that support them.  Untranslated arguments are
                  required on OS X, which doesn't support USDT translators.
                  The default value is selected based on your system and you
                  should never need to override this.

This tool uses the Node.js DTrace provider and dtrace(1M).  You must have
appropriate permissions to run it.
USAGE
	exit 2
}

function fail
{
	echo "$nhs_arg0: $*" >&2
	exit 1
}

#
# optsplit str
#
# Split a comma- or whitespace-separated string into its constituent pieces.
# This is used to split the -p option (typically something like "-p pid1 pid2")
# and the "-o" option (typically something like "-o col1,col2").
#
function optsplit
{
	for arg in "$@"; do
		IFS=,
		for carg in $arg; do
			echo $carg
		done
		IFS=
	done
}

#
# join sep arg1 ...
#
# Join the arguments (strings) with the given separator string.
#
function join
{
	local sep=$1
	shift

	echo -n "$1"
	shift

	for elt in "$@"; do
		echo -ne "$sep"
		echo -n "$elt"
	done
}

#
# emit_printf fmt arg1 ...
#
# Emit a DTrace "printf" statement.
#
function emit_printf
{
	local fmt="$1"
	shift

	echo -ne "\tprintf($fmt,\n\t    "
	join ",\n\t    " "$@"
	echo ");"
}

#
# emit_header
#
# Emit a header row for the currently selected columns.
#
function emit_header
{
	local fmts= args=
	for column in $nhs_cols; do
		case $column in
		fd)
			fmts="$fmts %4s"
			args="$args \"FD\""
			;;

		latency)
			fmts="$fmts %10s"
			args="$args \"LATENCY\""
			;;

		method)
			fmts="$fmts %-6s"
			args="$args \"METHOD\""
			;;

		path)
			fmts="$fmts %-20s"
			args="$args \"PATH\""
			;;

		pid)
			fmts="$fmts %6s"
			args="$args \"PID\""
			;;

		raddr)
			fmts="$fmts %-16s"
			args="$args \"RADDR\""
			;;

		rport)
			fmts="$fmts %5s"
			args="$args \"RPORT\""
			;;

		time)
			fmts="$fmts %-12s"
			args="$args \"TIME\""
			;;

		url)
			fmts="$fmts %-20s"
			args="$args \"URL\""
			;;

		which)
			fmts="$fmts %2s"
			args="$args \"\""
			;;

		esac
	done

	emit_printf "\"$(join " " $fmts)\\\\n\"" $args
}

#
# emit_row request|response conn method uri
#
# Emit the body of a DTrace clause that will print out the fields requested by
# the user.  Because the http-server-request and http-server-response probes
# access their arguments differently, the caller specifies how to access the
# connection object and the method and URI in the current context.
#
function emit_row
{
	local which=$1 fd=$2 raddr=$3 rport=$4 method=$5 uri=$6
	local fmts=
	local args=
	local lat=

	for column in $nhs_cols; do
		case $column in
		fd)
			fmts="$fmts %4d"
			args="$args $fd"
			;;

		latency)
			if [[ $which = "request" ]]; then
				fmts="$fmts %10s"
				args="$args \"-\""
			else
				fmts="$fmts %4d.%-03dms"
				lat="(timestamp-rqstarts[$raddr,$rport])"
				args="$args $lat/MICROSEC"
				args="$args ($lat%MICROSEC)/1000"
			fi
			;;

		method)
			fmts="$fmts %-6s"
			args="$args $method"
			;;

		path)
			fmts="$fmts %-20s"
			args="$args strtok($uri,\"?\")"
			;;

		pid)
			fmts="$fmts %6d"
			args="$args pid"
			;;

		raddr)
			fmts="$fmts %-16s"
			args="$args $raddr"
			;;

		rport)
			fmts="$fmts %5d"
			args="$args $rport"
			;;

		time)
			fmts="$fmts [%3d.%06d]"
			args="$args (timestamp-start)/NANOSEC"
			args="$args (timestamp-start)%MICROSEC"
			;;

		url)
			fmts="$fmts %-20s"
			args="$args $uri"
			;;

		which)
			if [[ $which = "request" ]]; then
				fmts="$fmts ->"
			else
				fmts="$fmts <-"
			fi
			;;

		*)
			fail "invalid column name: $column"
			;;
			
		esac
	done

	emit_printf "\"$(join " " $fmts)\\\\n\"" $args
}

nhs_arg0=$(basename $0)			# program name (for error messages)
nhs_tmpfile=/var/tmp/$nhs_arg0.$$.d	# dynamically-generated D script
nhs_pids=				# selected pids (-p)
nhs_cols=				# selected columns (-o)
nhs_dryrun="false"			# just print script and exit (-n)
nhs_tracestart="false"			# print "request" events (-l)
nhs_argtype="translated"		# use translated args (see below)

#
# OS X does not support translated arguments with USDT, so we default to using
# the untranslated versions.  We don't do this on other systems (e.g., illumos,
# BSD) because the untranslated arguments are not present in older versions of
# the provider there and because the untranslated arguments are more limited if
# we ever extend the translated ones.  (The untranslated versions are always
# available on OS X because the provider wasn't supported there before they were
# added.)  This behavior can be overridden using the "-t" option.
#
[[ $(uname -s) = "Darwin" ]] && nhs_argtype="simple"

while getopts "lno:p:t:" c; do
	case $c in
	l)	nhs_tracestart="true"		;;
	n)	nhs_dryrun="true"		;;
	o)	nhs_cols=$(optsplit $OPTARG)	;;
	p)	nhs_pids=$(optsplit $OPTARG)	;;
	t)	nhs_argtype="$OPTARG"		;;
	*)	usage
	esac
done

# Configure default columns.
if [[ -z "$nhs_cols" ]]; then
	if [[ $nhs_tracestart = "true" ]]; then
		nhs_cols="time pid which latency method path"
	else
		nhs_cols="time pid latency method path"
	fi
fi

#
# For readability, we define bash variables to contain the D expressions used
# for the various pieces of information we need.  The expression depends on the
# nhs_argtype (-t) option as well as which probe we're looking at ("request" or
# "response").
#
if [[ $nhs_argtype = "translated" ]]; then
	rqarg_fd="args[1]->fd"
	rqarg_raddr="args[1]->remoteAddress"
	rqarg_rport="args[1]->remotePort"
	rqarg_method="args[0]->method"
	rqarg_url="args[0]->url"

	rsarg_fd="args[0]->fd"
	rsarg_raddr="args[0]->remoteAddress"
	rsarg_rport="args[0]->remotePort"
elif [[ $nhs_argtype = "simple" ]]; then
	rqarg_fd="\"-\""
	rqarg_raddr="copyinstr(arg2)"
	rqarg_rport="arg3"
	rqarg_method="copyinstr(arg4)"
	rqarg_url="copyinstr(arg5)"

	rsarg_fd="\"-\""
	rsarg_raddr="copyinstr(arg1)"
	rsarg_rport="arg2"
else
	echo "$nhs_arg0: invalid value for \"-t\" option: \"$nhs_argtype\""
	usage 
fi

cat > $nhs_tmpfile <<EOF
#!/usr/sbin/dtrace -Cs

#pragma D option quiet

#define MILLISEC (1000)
#define	MICROSEC (1000 * 1000)
#define	NANOSEC  (1000 * 1000 * 1000)

BEGIN
{
$(emit_header)
	start = timestamp;
}

node*:::http-server-request
EOF

#
# We generate the DTrace script dynamically based on the options given.  If -p
# was specified, we predicate our first probe on the given set of pids.
#
if [[ -n "$nhs_pids" ]]; then
	set -- $nhs_pids

	if [[ $# -eq 1 ]]; then
		echo "/pid == $1/" >> $nhs_tmpfile
	else
		echo "/pid == $1" >> $nhs_tmpfile
		shift
		for pid in "$@"; do
			echo " || pid == $pid" >> $nhs_tmpfile
		done
		echo "/" >> $nhs_tmpfile
	fi
fi

echo "{" >> $nhs_tmpfile

[[ $nhs_tracestart = "true" ]] && 
	emit_row "request" $rqarg_fd $rqarg_raddr $rqarg_rport $rqarg_method \
	    $rqarg_url  >> $nhs_tmpfile

cat >> $nhs_tmpfile <<EOF
	rqstarts[$rqarg_raddr, $rqarg_rport] = timestamp;
	rqmethods[$rqarg_raddr, $rqarg_rport] = $rqarg_method;
	rqurls[$rqarg_raddr, $rqarg_rport] = $rqarg_url;
}

node*:::http-server-response
/rqstarts[$rsarg_raddr, $rsarg_rport]/
{
$(emit_row "response" $rsarg_fd $rsarg_raddr $rsarg_rport	\
    "rqmethods[$rsarg_raddr,$rsarg_rport]" "rqurls[$rsarg_raddr,$rsarg_rport]")
	rqstarts[$rsarg_raddr, $rsarg_rport] = 0;
	rqmethods[$rsarg_raddr, $rsarg_rport] = 0;
	rqurls[$rsarg_raddr, $rsarg_rport] = 0;
}

EOF

if [[ $nhs_dryrun = "true" ]]; then
	cat $nhs_tmpfile
	rm -f $nhs_tmpfile
	exit 0
fi

chmod +x $nhs_tmpfile
dtrace $DTRACE_OPTS -Cs $nhs_tmpfile || \
    echo "$nhs_arg0: failed to invoke dtrace(1M)" >&2
rv=$?
rm -f $nhs_tmpfile
exit $rv
